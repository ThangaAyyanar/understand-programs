* Logging

Logging refers to the process of recording events, activities, or data
generated by a system, application, or user. It is commonly used in
various fields, including software development, system administration,
and network management.

* Logging provides visibility into your application’s behavior, helping to,
1. Diagnose and troubleshoot issues (This is most common usecase)
2. Monitor application health and performance (Metrics)
3. Meet compliance and auditing requirements (Audit Logs)
4. Enable debugging in production environments (we all do this.)

However, poorly designed logging strategies can lead to excessive log volumes, higher costs, and difficulty in pinpointing actionable insights.

We will use *logging.properties* file to customize java logging

* What to be included in a Logger ?

** Which is a best logger ?

I’m not here to argue about which logger is the best, they all have their problems.
But the worst one is usually the one you build yourself. Sure, existing loggers aren’t perfect, but trying to create your own is often a much bigger mistake.

** Some Best Approaches (Not Hard Rule)

*** 1. Use Structured Logs
Long story short, instead of unstructured plain text, use JSON or other structured formats. This makes parsing and querying easier, especially in log aggregation tools.

#+begin_src json
{
  "timestamp": "2025-01-20T12:34:56Z",
  "level": "INFO",
  "message": "User login successful",
  "userId": 12345,
  "sessionId": "abcde12345"
}
#+end_src

*** 2. Leverage Logging Levels
Define and adhere to appropriate logging levels to avoid log bloat:

- DEBUG: Detailed information for debugging.
- INFO: General operational messages.
- WARNING: Indications of potential issues.
- ERROR: Application errors that require immediate attention.
- CRITICAL: Severe errors leading to application failure.

*** 3. Avoid Sensitive Data

Sanitize your logs to exclude sensitive information like passwords, PII, or API keys. Instead, mask or hash such data. Don’t add token even for testing.

*** 4. Include Contextual Information
Incorporate metadata like request IDs, user IDs, or transaction IDs to trace specific events effectively.

*** 5. Don't Log Everything at a same level
Logging all messages at the INFO or DEBUG level creates noise and makes it difficult to identify critical issues.

*** 6. Don't Hardcode Log Messages
Avoid static, vague, or generic log messages. Use dynamic and descriptive messages that include relevant context.

#+begin_src java
# Bad Example
Error occurred.
 
# Good Example
Error occurred while processing payment for user_id=12345, transaction_id=abc-6789.
#+end_src

*** 7. Don't ignore log rotation
Failing to implement log rotation can result in disk space exhaustion, especially in high traffic systems (Log Retention).

*** 8. Don't overlook log correlation
Logs without request IDs, session IDs, or contextual metadata make it difficult to correlate related events.

*** 9. Keep the log message short
Long and verbose messages are a cost. The cost is in reading time and ingestion time.

*** 10. Never use log message in a loop
This might seem obvious, but just to be clear -> logging inside a loop, even if the log level isn’t visible by default, can still hurt performance. It’s best to avoid this whenever possible.

If you absolutely need to log something at a hidden level and decide to break this guideline, keep it short and straightforward.

*** 11. Log item you already have
We should avoid this, 

#+begin_src java
logger.info("Reached X and value of method is {}", method());
#+end_src

Here, just for the logging purpose, we are calling the method() again. Even if the method is cheap. You’re effectively running the method regardless of the respective logging levels!

*** 12. Don't Log Iterables
Even if it’s a small list. The concern is that the list might grow and “overcrowd” the log. Writing the content of the list to the log can balloon it up and slow processing noticeably. Also kills time in debugging. 

*** 13. Don’t log Method Entry/Exit
Log only important events in the system. Entering or exiting a method isn’t an important event. E.g. if I have a method that enables feature X the log should be “Feature X enabled” and not “enable_feature_X entered”. I have done this a lot.

*** 14. Dont fill the method
A complex method might include multiple points of failure, so it makes sense that we’d place logs in multiple points in the method so we can detect the failure along the way. Unfortunately, this leads to duplicate logging and verbosity.

Errors will typically map to error handling code which should be logged in generically. So all error conditions should already be covered.

This creates situations where we sometimes need to change the flow/behavior of the code, so logging will be more elegant.

* Logging for metrics

Below, is the list of items that i wish can be logged for metrics.

** General API Metrics

1. General API Metrics on HTTP methods, status codes, latency/duration, request size.
2. Total requests per endpoint over time. Requests per minute/hour.
3. Frequency and breakdown of 4XX and 5XX errors.
4. User ID or API client making the request.

#+begin_src json
{
  "timestamp": "2025-01-20T12:34:56Z",
  "endpoint": "/projects",
  "method": "POST",
  "status_code": 201,
  "user_id": 12345,
  "request_size_bytes": 512,
  "response_size_bytes": 256,
  "duration_ms": 120
}
#+end_src

** Business Specific Metrics

1. Objects (session) creations: No. of projects created (daily/weekly)
2. Average success/failure rate.
3. Average time to create a session.
4. Frequency of each action on top of session.

#+begin_src json
{
  "timestamp": "2025-01-20T12:35:00Z",
  "endpoint": "/projects/12345/actions",
  "action": "edit",
  "status_code": 200,
  "user_id": 12345,
  "duration_ms": 98
}
#+end_src

** Performance Metrics

1. Database query metrics on execution time, no. of queries per request.
2. Third party service metrics on time spent, success/failure rates of external calls.

#+begin_src json
{
  "timestamp": "2025-01-20T12:37:15Z",
  "endpoint": "/projects/12345",
  "db_query_time_ms": 45,
  "external_api_time_ms": 80,
  "status_code": 200,
  "duration_ms": 130
}
#+end_src



- logging.properties

#+begin_example
# Define handlers for file and console logging
handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler

# Set global logging level to INFO
.level = INFO

# Log file output in a dedicated directory, e.g., /var/log/myapp/
java.util.logging.FileHandler.pattern = java%u.log
java.util.logging.FileHandler.limit = 50000
java.util.logging.FileHandler.count = 1
java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter

# Console logging settings
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

# Define a custom log format
java.util.logging.SimpleFormatter.format = [%1$td-%1$tm-%1$tY %1$tH:%1$tM:%1$tS] [%4$s] %5$s %n

# Set log level for a specific package, e.g., com.myapp
#com.myapp.level = WARNING
#+end_example

- Using logging.properties in java

#+begin_src java
import java.io.IOException;
import java.io.InputStream;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;

public class CustomLoggingPropertiesExample {

    // Create a logger for the class
    private static final Logger logger = Logger.getLogger(CustomLoggingPropertiesExample.class.getName());

    public static void main(String[] args) {
        // Load the custom logging.properties file
        try (InputStream inputStream = CustomLoggingPropertiesExample.class.getClassLoader()
                .getResourceAsStream("logging.properties")) {
            if (inputStream == null) {
                throw new RuntimeException("logging.properties file not found!");
            }
            LogManager.getLogManager().readConfiguration(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Log messages
        logger.info("This is an INFO message."); // Will NOT be logged
        logger.warning("This is a WARNING message."); // Will NOT be logged
        logger.severe("This is a SEVERE message."); // Will be logged
    }
}
#+end_src
